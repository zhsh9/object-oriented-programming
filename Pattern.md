# Inventory

- [Inventory](#inventory)
- [Reference](#reference)
- [命令模式](#命令模式)
- [迭代器模式](#迭代器模式)
- [访问者模式](#访问者模式)
  - [构建者模式](#构建者模式)
- [工厂模式](#工厂模式)
- [原型模式](#原型模式)
- [适配器模式](#适配器模式)
- [桥接模式](#桥接模式)
- [责任链模式](#责任链模式)
- [解释器模式](#解释器模式)


# Reference

- [设计模式目录](https://refactoringguru.cn/design-patterns/catalog)
- [菜鸟教程 - 设计模式 - Java实现](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)



# 一句话总结

- 创建型
  - 构造者模式
    - 分步骤创建复杂对象
    - 使用相同的创建代码生成不同类型和形式的对象
  - 抽象工厂模式
    - 创建一系列相关的对象， 而无需指定其具体类
  - 工厂方法模式
    - 在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型
  - 静态工厂模式
    - 工厂模式中只有固定具体的一个工厂
  - 原型模式
    - 能够复制已有对象， 而又无需使代码依赖它们所属的类
    - 生成完全相同的对象副本
  - 单例模式
    - 保证一个类只有一个实例， 并提供一个访问该实例的全局节点
    - 违反了单一职责原则，既充当了工厂角色，同时又充当了产品角色
    - 可能会导致共享连接池对象的程序过多而出现连接池溢出

- 结构型
  - 适配器
    - 使接口不兼容的对象能够相互合作
    - 分别继承至目标程序和新接口, 在适配器内重写目标程序接口, 调用新接口
    - 分类
      - 类适配器
      - 对象适配器
  - 桥接
    - 将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用
  - 组合
    - 将对象组合成树状结构， 并且能像使用独立对象一样使用它们
  - 装饰
    - 将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为
  - 外观
    - 为程序库、 框架或其他复杂类提供一个简单的接口
    - 外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为
  - 享元
    - 摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象
    - 享元模式通过共享技术实现相同或相似对象的重用
  - 代理
    - 代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务
- 行为型
  - 状态
    - 允许一个对象在其内部状态改变时改变它的行为
  - 策略
    - 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换
  - 观察者
    - 观察者收到通知后可以执行一些操作来回应发布者的通知
  - 中介者
    - 减少对象之间混乱无序的依赖关系。 
    - 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。
  - 迭代器
    - 在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素
    - 在迭代器的帮助下， 客户端可以用一个迭代器接口以相似的方式遍历不同集合中的元素
  - 访问者
    - 将算法与其所作用的对象隔离开来
  - 命令
    - 将请求转换为一个包含与请求相关的所有信息的独立对象。
    - 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。
    - 具体
      - 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作
      - 对命令进行封装，将发出命令的责任和执行命令的责任分割开
  - 责任链
    - 将请求沿着处理者链进行发送。
    - 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。
  - 解释器
    - 实现了一个表达式接口，该接口解释一个特定的上下文

# 组合模式

- **组合模式**是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

![image-20230616084332709](.Pattern.assets/image-20230616084332709.png)

# 策略模式

- **策略模式**是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

![image-20230616090644773](.Pattern.assets/image-20230616090644773.png)

![img](.Pattern.assets/1686669203473-bc6de04d-3568-4045-8daa-7d0dd93da83d.jpeg)

# 装饰器模式



# 命令模式

- **命令模式**是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。
- 为每个可能的操作实现一系列命令类， 并且根据按钮所需行为将命令和按钮连接起来。
- **命令**是一种行为设计模式， 它可将请求或简单操作转换为一个对象。此类转换让你能够延迟进行或远程执行请求， 还可将其放入队列中。

![image-20230616044143538](.Pattern.assets/image-20230616044143538.png)

![image.png](.Pattern.assets/1678774124076-d7e380de-5916-4346-8a96-c3009e5a926c.png)

# 迭代器模式

- **迭代器模式**是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。
- 迭代器模式的主要思想是将集合的遍历行为抽取为单独的*迭代器*对象。
- 在迭代器的帮助下， 客户端可以用一个迭代器接口以相似的方式遍历不同集合中的元素。

![image-20230616050714850](.Pattern.assets/image-20230616050714850.png)

# 访问者模式

- **访问者模式**是一种行为设计模式， 它能将算法与其所作用的对象隔离开来；允许你在不修改已有代码的情况下向已有类层次结构中增加新的行为。
- 访问者模式建议将新行为放入一个名为*访问者*的独立类中， 而不是试图将其整合到已有类中。 现在， 需要执行操作的原始对象将作为参数被传递给访问者中的方法， 让方法能访问对象所包含的一切必要数据。

![image-20230616051426885](.Pattern.assets/image-20230616051426885.png)

![img](.Pattern.assets/1683340876794-7d7a1145-474d-4fb8-8921-42b92f54a7e1.png)

# 构建者模式

生成器模式建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为*生成器*的独立对象中。

![image-20230616052446952](.Pattern.assets/image-20230616052446952.png)

![image.png](.Pattern.assets/1683341061457-f341b950-3e67-4c73-b8ce-e2910ada10e7.png)

# 工厂模式

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。

![image-20230616052729185](.Pattern.assets/image-20230616052729185.png)

![image.png](.Pattern.assets/1678759713249-63c9b101-2048-45b4-a5f9-ea3f327f8ebf.png)

# 原型模式

- 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。
- 原型是一种创建型设计模式， 使你能够复制对象， 甚至是复杂对象， 而又无需使代码依赖它们所属的类。
- 所有的原型类都必须有一个通用的接口， 使得即使在对象所属的具体类未知的情况下也能复制对象。 原型对象可以生成自身的完整副本， 因为相同类的对象可以相互访问对方的私有成员变量。

![image-20230616061909856](.Pattern.assets/image-20230616061909856.png)

GraphicTool找不到具体Graphic类：

![image.png](.Pattern.assets/1683685848596-40c9756c-daa9-4c6b-99de-16c7c441dc61.png)

1. 工程模式：每种乐谱对象都创建对应的工厂类, 每次调用特定的工厂创建乐谱类

![image.png](.Pattern.assets/1683686393261-3e374077-c070-4b98-a104-9d227f654da7.png)

2. 原型模式：每次仅需要切换原型, 就可以通过 clone 创建新类, 比工厂消耗更少的资源

![image.png](.Pattern.assets/1683686859281-56837e70-42b7-4b8b-bc37-f4e05cfbb41e.png)

# 适配器模式

- **适配器模式**是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。
- 你可以创建一个*适配器*。 这是一个特殊的对象， 能够转换对象接口， 使其能与其他对象进行交互。
- 适配器可担任两个对象间的封装器， 它会接收对于一个对象的调用， 并将其转换为另一个对象可识别的格式和接口。

![image-20230616063322376](.Pattern.assets/image-20230616063322376.png)

![image-20230616063343230](.Pattern.assets/image-20230616063343230.png)

Example: 在 TextShape 中使用了 TextView 的方法, TextShape 这里做适配器, 整合 Shape 和 TextView 俩个方法

![image.png](https://cdn.nlark.com/yuque/0/2023/png/2327383/1683687617449-e9d1597e-fd71-4ead-b4d1-9286287415d0.png)

Example: lambda实现适配器

- lambda
  - [ ]
  - [&]
  - [=]
  - [x, &y]
  - [&, x]
  - [=, &z]
  - [this]
- std::function
- closure

`Requset` 是一个函子, 通过切换不同的函子, 以实现多功能适配器:

![image.png](.Pattern.assets/1678722742688-82268bfa-a902-4bd3-a14d-8f3f0321c2eb.png)

# 桥接模式

- **桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。
- 层次结构中的第一层 （通常称为抽象部分） 将包含对第二层 （实现部分） 对象的引用。 抽象部分将能将一些 （有时是绝大部分） 对自己的调用委派给实现部分的对象。 所有的实现部分都有一个通用接口， 因此它们能在抽象部分内部相互替换。

![image-20230616064043642](.Pattern.assets/image-20230616064043642.png)

Example: 我有一个 `Window` , 现在我需要实现 `dialog` 功能。将抽象部分和实现部分分离, 将 `X` 功能的实现进行抽离, `DialogWindow` 有一个操作指针, 要 `X` 功能就把 `imp` 指向 `X` 操作类, 要 `PM` 功能就把 `imp` 指向 `PM` 操作类, 不需要额外重写 `PMDialogWindow`

![image.png](.Pattern.assets/1684290539572-9895c5c5-ea70-4888-8d46-56d3c6aec1e1.png)

# 责任链模式

- **责任链模式**是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。
- 该模式允许多个对象来对请求进行处理， 而无需让发送者类与具体接收者类相耦合。 链可在运行时由遵循标准处理者接口的任意处理者动态生成。

![image-20230616064422736](.Pattern.assets/image-20230616064422736.png)

![image.png](.Pattern.assets/1678709530066-492cbde6-b8df-4026-b430-734a6ee3031f.png)

# 解释器模式

- 提供了评估语言的语法或表达式的方式，它属于行为型模式。
- 这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。
- 关键代码：构建环境类，包含解释器之外的一些全局信息，一般是 HashMap

![image.png](.Pattern.assets/1684894471068-f7fa8971-baaa-470d-ba89-a0af3b8636cd.png)

Example: bool expression

![image.png](.Pattern.assets/1678710887539-01756a2d-214a-409a-ab92-896076fbd04b.png)
